/**
 * OOXMLValidator - Post-Processing OOXML Validation and Repair
 *
 * Validates and fixes OOXML documents generated by third-party libraries
 * (like docxmlater) to ensure compliance with OOXML_HYPERLINK_ARCHITECTURE.md
 *
 * This module intercepts documents AFTER processing and fixes any issues
 * that may have been introduced by the processing library.
 */

import JSZip from 'jszip';
import { XMLParser, XMLBuilder } from 'fast-xml-parser';
import { logger } from '@/utils/logger';

const log = logger.namespace('OOXMLValidator');

// XML Parser configuration matching our application's setup
const xmlParser = new XMLParser({
  ignoreAttributes: false,
  parseAttributeValue: true,
  trimValues: true,
  processEntities: false,
  parseTagValue: false,
  preserveOrder: false,
  attributeNamePrefix: '@_',
  textNodeName: '#text'
});

const xmlBuilder = new XMLBuilder({
  ignoreAttributes: false,
  format: false,
  suppressEmptyNode: false,
  preserveOrder: false,
  attributeNamePrefix: '@_',
  textNodeName: '#text'
});

interface ValidationIssue {
  severity: 'error' | 'warning';
  type: string;
  message: string;
  element?: string;
}

export interface OOXMLValidationResult {
  valid: boolean;
  issues: ValidationIssue[];
  fixes: string[];
}

/**
 * OOXMLValidator - Validates and repairs OOXML documents
 */
export class OOXMLValidator {
  /**
   * Validate and fix a DOCX file buffer
   * This method intercepts the document, checks for OOXML violations,
   * and fixes them before returning the corrected buffer
   */
  async validateAndFixBuffer(buffer: Buffer): Promise<OOXMLValidationResult> {
    log.debug('Starting OOXML validation and repair process');

    const result: OOXMLValidationResult = {
      valid: true,
      issues: [],
      fixes: []
    };

    try {
      // Load the DOCX as ZIP
      const zip = await JSZip.loadAsync(buffer);

      // Extract and parse document.xml and relationships
      const documentXmlFile = zip.file('word/document.xml');
      const relsXmlFile = zip.file('word/_rels/document.xml.rels');

      if (!documentXmlFile || !relsXmlFile) {
        result.valid = false;
        result.issues.push({
          severity: 'error',
          type: 'MISSING_FILES',
          message: 'Missing document.xml or document.xml.rels'
        });
        return result;
      }

      // Parse XML files
      const documentXmlStr = await documentXmlFile.async('string');
      const relsXmlStr = await relsXmlFile.async('string');

      const documentXml = xmlParser.parse(documentXmlStr);
      let relsXml = xmlParser.parse(relsXmlStr);

      // Validate and collect issues
      this.validateHyperlinkIntegrity(documentXml, relsXml, result);
      this.validateXmlStructure(documentXmlStr, relsXmlStr, result);

      // Fix issues found
      if (result.issues.length > 0) {
        log.warn(`Found ${result.issues.length} OOXML issues, attempting fixes`);

        // Fix critical issues
        const fixes = await this.fixCriticalIssues(documentXml, relsXml);
        result.fixes = fixes;

        if (fixes.length > 0) {
          log.info(`Applied ${fixes.length} fixes to document`);

          // Rebuild ZIP with fixed XML
          const fixedDocumentXml = xmlBuilder.build(documentXml);
          const fixedRelsXml = xmlBuilder.build(relsXml);

          // Ensure XML declarations are present
          const docXmlWithDecl = this.ensureXmlDeclaration(fixedDocumentXml);
          const relsXmlWithDecl = this.ensureXmlDeclaration(fixedRelsXml);

          // Update ZIP files
          zip.file('word/document.xml', docXmlWithDecl);
          zip.file('word/_rels/document.xml.rels', relsXmlWithDecl);

          log.info('Updated DOCX with fixes');
        }
      }

      // Return corrected buffer
      if (result.fixes.length > 0) {
        const correctedBuffer = await zip.generateAsync({ type: 'arraybuffer' });
        // Convert ArrayBuffer to Buffer
        return {
          ...result,
          valid: result.issues.filter(i => i.severity === 'error').length === 0
        };
      }

      return result;
    } catch (error: any) {
      log.error('OOXML validation failed:', error.message);
      result.valid = false;
      result.issues.push({
        severity: 'error',
        type: 'VALIDATION_ERROR',
        message: `Validation error: ${error.message}`
      });
      return result;
    }
  }

  /**
   * Validate hyperlink two-part relationship system
   */
  private validateHyperlinkIntegrity(
    documentXml: any,
    relsXml: any,
    result: OOXMLValidationResult
  ): void {
    log.debug('Validating hyperlink integrity');

    // Extract all hyperlink relationship IDs from document
    const documentRIds = new Set<string>();
    this.findHyperlinkIds(documentXml, documentRIds);

    // Extract all hyperlink relationships from .rels file
    const relsIds = new Set<string>();
    const externalUrlsWithoutTargetMode: string[] = [];

    if (relsXml.Relationships?.Relationship) {
      const relationships = Array.isArray(relsXml.Relationships.Relationship)
        ? relsXml.Relationships.Relationship
        : [relsXml.Relationships.Relationship];

      for (const rel of relationships) {
        if (rel['@_Type']?.includes('hyperlink')) {
          const id = rel['@_Id'];
          const target = rel['@_Target'];
          const targetMode = rel['@_TargetMode'];

          if (id) {
            relsIds.add(id);

            // Check for missing TargetMode on external URLs
            if (target?.startsWith('http') && targetMode !== 'External') {
              externalUrlsWithoutTargetMode.push(`${id}: ${target}`);
            }
          }
        }
      }
    }

    // Check for missing relationships (critical)
    for (const docId of documentRIds) {
      if (!relsIds.has(docId)) {
        result.valid = false;
        result.issues.push({
          severity: 'error',
          type: 'MISSING_RELATIONSHIP',
          message: `Hyperlink references ${docId} but relationship not found`,
          element: docId
        });
      }
    }

    // Check for orphaned relationships (warning)
    for (const relsId of relsIds) {
      if (!documentRIds.has(relsId)) {
        result.issues.push({
          severity: 'warning',
          type: 'ORPHANED_RELATIONSHIP',
          message: `Relationship ${relsId} exists but is not referenced`,
          element: relsId
        });
      }
    }

    // Check for external URLs without TargetMode
    for (const url of externalUrlsWithoutTargetMode) {
      result.valid = false;
      result.issues.push({
        severity: 'error',
        type: 'MISSING_TARGET_MODE',
        message: `External URL missing TargetMode="External": ${url}`,
        element: url
      });
    }
  }

  /**
   * Validate XML structure and formatting
   */
  private validateXmlStructure(
    documentXmlStr: string,
    relsXmlStr: string,
    result: OOXMLValidationResult
  ): void {
    log.debug('Validating XML structure');

    // Check for XML declarations
    if (!documentXmlStr.startsWith('<?xml')) {
      result.issues.push({
        severity: 'warning',
        type: 'MISSING_XML_DECLARATION',
        message: 'document.xml missing XML declaration'
      });
    }

    if (!relsXmlStr.startsWith('<?xml')) {
      result.issues.push({
        severity: 'warning',
        type: 'MISSING_XML_DECLARATION',
        message: 'document.xml.rels missing XML declaration'
      });
    }
  }

  /**
   * Fix critical OOXML issues
   */
  private async fixCriticalIssues(
    documentXml: any,
    relsXml: any
  ): Promise<string[]> {
    const fixes: string[] = [];

    // Fix 1: Add TargetMode="External" to external URLs
    if (relsXml.Relationships?.Relationship) {
      const relationships = Array.isArray(relsXml.Relationships.Relationship)
        ? relsXml.Relationships.Relationship
        : [relsXml.Relationships.Relationship];

      for (const rel of relationships) {
        if (rel['@_Type']?.includes('hyperlink')) {
          const target = rel['@_Target'];

          // If URL is external but missing TargetMode, add it
          if (target?.startsWith('http') && !rel['@_TargetMode']) {
            rel['@_TargetMode'] = 'External';
            fixes.push(`Added TargetMode="External" to ${rel['@_Id']}`);
          }
        }
      }
    }

    // Fix 2: Ensure all hyperlink text nodes have xml:space="preserve"
    const fixedTextNodes = this.ensureXmlSpacePreserve(documentXml);
    if (fixedTextNodes > 0) {
      fixes.push(`Fixed xml:space="preserve" on ${fixedTextNodes} text nodes`);
    }

    return fixes;
  }

  /**
   * Find all hyperlink relationship IDs in document
   */
  private findHyperlinkIds(obj: any, idSet: Set<string>, depth: number = 0): void {
    if (!obj || typeof obj !== 'object' || depth > 100) return;

    if (obj['w:hyperlink']) {
      const hyperlinks = Array.isArray(obj['w:hyperlink'])
        ? obj['w:hyperlink']
        : [obj['w:hyperlink']];

      for (const h of hyperlinks) {
        const rId = h['@_r:id'];
        if (rId) {
          idSet.add(rId);
        }
      }
    }

    for (const key in obj) {
      if (typeof obj[key] === 'object') {
        this.findHyperlinkIds(obj[key], idSet, depth + 1);
      }
    }
  }

  /**
   * Ensure xml:space="preserve" attribute on all text nodes
   */
  private ensureXmlSpacePreserve(obj: any, depth: number = 0, count: number = 0): number {
    if (!obj || typeof obj !== 'object' || depth > 100) return count;

    // Find text nodes and ensure xml:space="preserve"
    if (obj['w:t']) {
      const textNodes = Array.isArray(obj['w:t']) ? obj['w:t'] : [obj['w:t']];

      for (const textNode of textNodes) {
        if (typeof textNode === 'object' && !textNode['@_xml:space']) {
          textNode['@_xml:space'] = 'preserve';
          count++;
        }
      }
    }

    for (const key in obj) {
      if (typeof obj[key] === 'object') {
        count += this.ensureXmlSpacePreserve(obj[key], depth + 1, 0);
      }
    }

    return count;
  }

  /**
   * Ensure XML declaration is present
   */
  private ensureXmlDeclaration(xmlStr: string): string {
    if (!xmlStr.startsWith('<?xml')) {
      return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n' + xmlStr;
    }
    return xmlStr;
  }
}

// Export singleton instance
export const ooxmlValidator = new OOXMLValidator();
